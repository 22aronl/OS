Due date:
    test: 11/08/2023 @ 11:59pm
    code: 11/10/2023 @ 11:59pm

Assignment:
~~~~~~~~~~~

- Implement more system calls
- Donate a test case

Physical address Space:
~~~~~~~~~~~~~~~~~~~~~~~

0x00000000 - kConfig.memSize  (DRAM)
kConfig.ioAPIC - ...+0x000    (the IOPIC device)
kConfig.localAPIC - ...+0x000 (the LAPIC device)

Virtual Address Space:
~~~~~~~~~~~~~~~~~~~~~~

0x00001000 - kConfig.memSize   (identity mapped kernel RW)
0x80000000 - 0xF0000000        (per-process, on demand, user RW)
0xF0000000 - 0xF0001000        (shared between all user processes)
kConfig.ioAPIC - ...+0x1000    (identity mapped kernel RW)
kConfig.localAPIC - ...+0x1000 (identity mapped kernel RW)
everything else                (no valid mapping)

User code should not be able to access anything outside the user
range (0x80000000 - 0xF0001000). Any attempt to do so should
force the faulting process to exit and store the faulting
address at (0xF0000800)

Details:
~~~~~~~~

Same as p8 with the following additions/changes.

=== changes ===

- [1005] void* simple_mmap(void* addr, unsigned size, int fd, unsigned offset)

    * same behavior as p8 if fd == -1, otherwise
    * if offset is not page aligned, fail and return 0
    * if fd does not refer to an valid file descriptor, fail and return 0
    * create a private virtual mapping as in p8 but fill it with the
      contents of the file starting at 'offset'
    * if size > (len(file)-offset) then fill the rest with zero

- signal handlers don't have to call sigreturn() directly. A handler that
  returns behaves as if it called sigreturn().

=== additions ===

- File descriptors

    * A process can have up to 10 open file descriptor (0 .. 9)
    * file descriptors are inherited on fork and preserved across exec
    * kernelInit initializes the file descriptors for the first process
      as follows:

         - 0: all read/write attempts fail (return -1)
         - 1: reads fail, writes go to the terminal
         - 2: reads fail, writes go to the terminal

- [1020] void chdir(char* path)

    * changes the current working directory of the calling process to 'path'
    * path doesn't have to be valid
    * CWD is initialized to '/'

- [1021] int open(char* path)

    * path could either be absolute of relative
    * opens the file at the given path and returns the lowest available
      descriptor
    * all errors returns -1 (path not valid, path not found, no available
      file descriptors)
    * it is legal to open a directory

- [1022] int close(fd)

    * closes the given file descriptor
    * returns 0 on success and -1 on failure

- [1023] int len(fd)

    * returns the length (in bytes) of the file referred to by fd
    * return -1 on failure

- [1024] int n = read(fd, void* buffer, unsigned count)

    * reads up to 'count' bytes from a file into buffer
    * failures are indicated by n == -1
        - buffer is not a valid user-accessible virtual address
        - fd doesn't refer to a readable file
    * n == 0 iff at end of file or count == 0
    * otherwise 0 < n <= count

- [1025] int n = write(fd, void* buffer, unsigned count)

    * writes up to 'count' bytes from buffer to the indicated file
    * failures are indicated by n == -1
        - buffer is not a valid user-accessible virtual address
        - fd doesn't refer to a writable file
    * n == 0 iff count == 0
    * otherwise, 0 < n <= count

- [1026] int rc = pipe(int* write_fd, int* read_fd)

    * creates an in-kernel bounded buffer of size 100 bytes
    * return 0 on success and -1 on failure
    * writing to *write_fd stores bytes in the bounded buffer
    * reading from *read_fd retrieves bytes from the bounded buffer
    * reading from *write_fd should fail
    * writing to *read_fd should fail

- [1027] int kill(unsigned v)

    * sends signal #2 to the youngest child
    * if the child has a handler then 'v' is passed as the 'arg'
    * if the child doesn't have a handler, then it is forced to
      exit with status 'v'


Files:
~~~~~~

- kernel/          contains the kernel files

- <test>.dir/      the contents of the root disk

- <test>.dir/sbin
    init.c         ... init source
    libc.c/libc.h  ... minimal libc implementation
    sys.S/sys.h    ... user-side system calls
    init           ... the ELF init file packaged in t0.img

For Makefile help:
~~~~~~~~~~~~~~~~~~

    make help

To run test:
~~~~~~~~~~~~

    make -s clean test

To run one test:
~~~~~~~~~~~~~~~~

    make -s t0.test

To make the output more noisy:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    make clean test

To run by hand
~~~~~~~~~~~~~~

    ./run_qemu t0

To attach with gdb
~~~~~~~~~~~~~~~~~~

    ./debug_qemu t0
