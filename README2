Same as p8 with the following additions/changes.

=== changes ===

- [1005] void* simple_mmap(void* addr, unsigned size, int fd, unsigned offset)

    * same behavior as p8 if fd == -1, otherwise
    * if offset is not page aligned, fail and return 0
    * if fd does not refer to an valid file descriptor, fail and return 0
    * create a private virtual mapping as in p8 but fill it with the
      contents of the file starting at 'offset'
    * if size > (len(file)-offset) then fill the rest with zero

- signal handlers don't have to call sigreturn() directly. A handler that
  returns behaves as if it called sigreturn().

=== additions ===

- File descriptors

    * A process can have up to 10 open file descriptor (0 .. 9)
    * file descriptors are inherited on fork and preserved across exec
    * kernelInit initializes the file descriptors for the first process
      as follows:

         - 0: all read/write attempts fail (return -1)
         - 1: reads fail, writes go to the terminal
         - 2: reads fail, writes go to the terminal

- [1020] void chdir(char* path)

    * changes the current working directory of the calling process to 'path'
    * path doesn't have to be valid
    * CWD is initialized to '/'
    * path may be relative to the current CWD

- [1021] int open(char* path)

    * path could either be absolute or relative
    * opens the file at the given path and returns the lowest available
      descriptor
    * all errors returns -1 (path not valid, path not found, no available
      file descriptors)
    * it is legal to open a directory

- [1022] int close(fd)

    * closes the given file descriptor
    * returns 0 on success and -1 on failure
    * fails if the file descriptor doesn't refer to an open file
    * closing a mmapped file descriptor does not invalidate the mapping

- [1023] int len(fd)

    * returns the length (in bytes) of the file referred to by fd
    * return -1 on failure
    * fails if the file descriptor doesn't refer to a regular file
      (normally this would be implemented in terms of lseek, so it
       would fail on non-seekable files -- pipes, directories, etc)

- [1024] int n = read(fd, void* buffer, unsigned count)

    * reads up to 'count' bytes from a file into buffer
    * failures are indicated by n == -1
        - buffer is not a valid user-accessible virtual address
        - fd doesn't refer to a readable file descriptor
        - directories are not readable
    * n == 0 iff at end of file or count == 0
    * otherwise 0 < n <= count
    * file descriptors store an internal offset; a second call
      to read will read bytes starting just after the end of the
      previously read bytes.

- [1025] (or [1]) int n = write(fd, void* buffer, unsigned count)

    * writes up to 'count' bytes from buffer to the indicated file
    * failures are indicated by n == -1
        - buffer is not a valid user-accessible virtual address
        - fd doesn't refer to a writable file descriptor
        - files on the ext2 filesystem are not currently writable
        - directories are not readable
    * n == 0 iff count == 0
    * otherwise, 0 < n <= count

- [1026] int rc = pipe(int* write_fd, int* read_fd)

    * creates an in-kernel bounded buffer of size 100 bytes
    * returns 0 on success and -1 on failure
    * allocates two files descriptors, the lowest available (write_fd < read_fd)
    * writes the two descriptors into the pointers passed to the syscall
        * writing to *write_fd stores bytes in the bounded buffer
        * reading from *read_fd retrieves bytes from the bounded buffer
        * reading from *write_fd should fail
        * writing to *read_fd should fail

- [1027] int kill(unsigned v)

    * sends signal #2 to the youngest child
    * if the child has a handler then 'v' is passed as the 'arg'
    * if the child doesn't have a handler, then it is forced to
      exit with status 'v'

    * kill does not block
    * returns 0 on success and -1 on failure
    * suceeds if the child exists and is alive at the point kill was called
    * fails if there are no remaining children, or if the youngest child has
      already exited
    * does not modify the stack of children

- [1028] int dup(int fd)

    * allocates a new file descriptor, the lowest available
    * makes the new file descriptor point to the same file/pipe/etc
      as the provided fd
    * the internal offset used by read is shared between duped file descriptors
    * returns 0 on success and -1 on failure
    * fails if:
        * there are no available file descriptors
        * if fd is not a valid file descriptor